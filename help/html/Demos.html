
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Demos</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-10-01"><meta name="DC.source" content="Demos.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>Demos</h1><!--introduction--><p>Different use cases of the <a href="matlab:doc('optimal_experimental_design_toolbox')"><tt>Optimal Experimental Design Toolbox</tt></a> are illustrated here with an example.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Create the model and the solver object</a></li><li><a href="#2">Calculate optimal measuring points</a></li><li><a href="#3">Calculate quality of measuring points</a></li><li><a href="#4">Estimate model parameter from accomplished measurements</a></li><li><a href="#5">Calculate gain of additional measurements</a></li><li><a href="#6">Calculate optimal measuring points with constraints</a></li></ul></div><h2>Create the model and the solver object<a name="1"></a></h2><pre class="codeinput">p = 1;                                     <span class="comment">% Parameter of the model</span>
p0 = (1 + rand() * 10^-1) * p              <span class="comment">% Guessed parameter value</span>

n = 5;                                     <span class="comment">% Number of possible measuring points</span>
t_var = (1/n:1/n:1)                        <span class="comment">% Possible measuring points</span>
v_var = 10^-2 * ones(1, n)                 <span class="comment">% Variance of measuring result at these measuring points</span>

model = model_explicit(<span class="string">'p*t'</span>, <span class="string">'p'</span>, <span class="string">'t'</span>);   <span class="comment">% Create the model object</span>
sol = solver(model, p0, t_var', v_var');   <span class="comment">% Create the solver object</span>
</pre><pre class="codeoutput">
p0 =

    1.0815


t_var =

    0.2000    0.4000    0.6000    0.8000    1.0000


v_var =

    0.0100    0.0100    0.0100    0.0100    0.0100

</pre><h2>Calculate optimal measuring points<a name="2"></a></h2><pre class="codeinput">max = 3;                                     <span class="comment">% Maximal number of measuring points to choose</span>
w_opt = sol.get_optimized_weightings(max)'   <span class="comment">% Calculate the optimal weighting of the possible measuring points</span>
t_opt = t_var(w_opt)                         <span class="comment">% Resulting optimal measuring points</span>
</pre><pre class="codeoutput">
w_opt =

     0     0     1     1     1


t_opt =

    0.6000    0.8000    1.0000

</pre><h2>Calculate quality of measuring points<a name="3"></a></h2><p>The smaller the value, the better the quality.</p><pre class="codeinput">quality_opt = sol.get_quality(w_opt)            <span class="comment">% Calculate quality resulting from optimal measurements</span>
w_subopt = [ones(1, max), zeros(1, n - max)]    <span class="comment">% Suboptimal weighting</span>
quality_subopt = sol.get_quality(w_subopt)      <span class="comment">% Calculate quality resulting from suboptimal measurements</span>
</pre><pre class="codeoutput">
quality_opt =

    0.0043


w_subopt =

     1     1     1     0     0


quality_subopt =

    0.0153

</pre><h2>Estimate model parameter from accomplished measurements<a name="4"></a></h2><pre class="codeinput">m = 5;                                                                         <span class="comment">% Number of accomplished measuring points</span>
t_fix = ((1/m:1/m:1) + 1)';                                                    <span class="comment">% Accomplished measuring points</span>
v_fix = 10^-2 * ones(n, 1);                                                    <span class="comment">% Variance of measuring result at these measuring points</span>
eta = model_util.get_fictitious_measurement_results(model, p, t_fix, v_fix);   <span class="comment">% Measuring results of the accomplished measurements</span>
sol.set_accomplished_measurements(t_fix, v_fix, eta);                          <span class="comment">% Pass accomplished measurements to the solver object</span>
p_lw = 0;                                                                      <span class="comment">% Lower bound of model parameter</span>
p_ub = 2;                                                                      <span class="comment">% Upper bound of model parameter</span>
p_opt = sol.get_optimized_parameters(p_lw, p_ub)                               <span class="comment">% Estimate model parameter from accomplished measurements</span>
</pre><pre class="codeoutput">
p_opt =

    0.9877

</pre><h2>Calculate gain of additional measurements<a name="5"></a></h2><pre class="codeinput">sol.set_initial_parameter_estimation(p_opt);   <span class="comment">% Update parameter estimation</span>
w_opt = sol.get_optimized_weightings(max)';    <span class="comment">% Calculate the optimal weighting of the possible measuring points</span>
quality_old = sol.get_quality(zeros(n, 1))     <span class="comment">% Calculate quality without additional measurements</span>
quality_new = sol.get_quality(w_opt)           <span class="comment">% Calculate quality resulting from optimal additional measurements</span>
</pre><pre class="codeoutput">
quality_old =

   7.7656e-04


quality_new =

   6.7439e-04

</pre><h2>Calculate optimal measuring points with constraints<a name="6"></a></h2><p>We are constraining the choose of measuring points in such a way that distance between two choosen measuring points has to be at least 0.4.</p><pre class="codeinput">A = diag(ones(m, 1)) + diag(ones(m - 1, 1), 1)   <span class="comment">% Matrix for the constraints of the measuring points</span>
b = ones(1, m)                                   <span class="comment">% Vector for the constraints of the measuring points</span>
w_opt = sol.get_optimized_weightings(A, b')'     <span class="comment">% Calculate the optimal weighting of the measuring points consider the constraints</span>
t_opt = t_var(w_opt)                             <span class="comment">% Resulting optimal measuring points</span>
</pre><pre class="codeoutput">
A =

     1     1     0     0     0
     0     1     1     0     0
     0     0     1     1     0
     0     0     0     1     1
     0     0     0     0     1


b =

     1     1     1     1     1


w_opt =

     1     0     1     0     1


t_opt =

    0.2000    0.6000    1.0000

</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
%% Demos
% Different use cases of the <matlab:doc('optimal_experimental_design_toolbox')
% |Optimal Experimental Design Toolbox|> are illustrated here with an example.


%% Create the model and the solver object
p = 1;                                     % Parameter of the model
p0 = (1 + rand() * 10^-1) * p              % Guessed parameter value

n = 5;                                     % Number of possible measuring points
t_var = (1/n:1/n:1)                        % Possible measuring points
v_var = 10^-2 * ones(1, n)                 % Variance of measuring result at these measuring points

model = model_explicit('p*t', 'p', 't');   % Create the model object
sol = solver(model, p0, t_var', v_var');   % Create the solver object


%% Calculate optimal measuring points
max = 3;                                     % Maximal number of measuring points to choose
w_opt = sol.get_optimized_weightings(max)'   % Calculate the optimal weighting of the possible measuring points
t_opt = t_var(w_opt)                         % Resulting optimal measuring points


%% Calculate quality of measuring points
% The smaller the value, the better the quality.
quality_opt = sol.get_quality(w_opt)            % Calculate quality resulting from optimal measurements
w_subopt = [ones(1, max), zeros(1, n - max)]    % Suboptimal weighting
quality_subopt = sol.get_quality(w_subopt)      % Calculate quality resulting from suboptimal measurements


%% Estimate model parameter from accomplished measurements
m = 5;                                                                         % Number of accomplished measuring points
t_fix = ((1/m:1/m:1) + 1)';                                                    % Accomplished measuring points
v_fix = 10^-2 * ones(n, 1);                                                    % Variance of measuring result at these measuring points
eta = model_util.get_fictitious_measurement_results(model, p, t_fix, v_fix);   % Measuring results of the accomplished measurements
sol.set_accomplished_measurements(t_fix, v_fix, eta);                          % Pass accomplished measurements to the solver object
p_lw = 0;                                                                      % Lower bound of model parameter
p_ub = 2;                                                                      % Upper bound of model parameter
p_opt = sol.get_optimized_parameters(p_lw, p_ub)                               % Estimate model parameter from accomplished measurements


%% Calculate gain of additional measurements
sol.set_initial_parameter_estimation(p_opt);   % Update parameter estimation
w_opt = sol.get_optimized_weightings(max)';    % Calculate the optimal weighting of the possible measuring points
quality_old = sol.get_quality(zeros(n, 1))     % Calculate quality without additional measurements
quality_new = sol.get_quality(w_opt)           % Calculate quality resulting from optimal additional measurements


%% Calculate optimal measuring points with constraints
% We are constraining the choose of measuring points in such a way that
% distance between two choosen measuring points has to be at least 0.4.
A = diag(ones(m, 1)) + diag(ones(m - 1, 1), 1)   % Matrix for the constraints of the measuring points
b = ones(1, m)                                   % Vector for the constraints of the measuring points
w_opt = sol.get_optimized_weightings(A, b')'     % Calculate the optimal weighting of the measuring points consider the constraints
t_opt = t_var(w_opt)                             % Resulting optimal measuring points

##### SOURCE END #####
--></body></html>